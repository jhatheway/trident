package trident

import (
	"bytes"
	"crypto/sha256"
	"errors"
	"fmt"
	"github.com/disintegration/imaging"
	"image"
	_ "image/gif"
	_ "image/jpeg"
	_ "image/png"
	"io"
	"io/ioutil"
	"log"
	"math/rand"
	"net"
	"os"
	"os/user"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"syscall"
	"time"
)

var LogLocation = false

func where_strippath(path string, workdir string, gopath string) (strippedpath string) {
	wl := len(workdir)
	fl := len(path)

	/* If the prefix matches, remove it, to lessen output */
	if wl > 1 && fl > (wl+1) && workdir == path[0:wl] {
		path = path[wl+1:]
	} else {
		/* Shrink too when in GOPATH */
		gp := filepath.Join(gopath, "src")
		gl := len(gp)

		if fl > (gl+1) && gp == path[0:gl] {
			path = path[gl+1:]
		}
	}

	return path
}

func Where(off int) string {
	file := "<autogenerated>"
	line := 0

	/* Unwrap interfaces, they show up as "<autogenerated>" */
	for n := 1; file == "<autogenerated>"; n++ {
		_, file, line, _ = runtime.Caller(n + off)
	}

	/* Get work directory (where we where started from) */
	wd, _ := os.Getwd()
	gopath := os.Getenv("GOPATH")

	/* Strip the path where possible */
	file = where_strippath(file, wd, gopath)

	return file + ":" + strconv.Itoa(line)
}

func LogLoc(off int, pfx string) string {
	if !LogLocation {
		if pfx != "" {
			return pfx + ": "
		}
		return ""
	}

	s := ""

	if pfx != "" {
		s += pfx + "("
	}

	s += Where(2 + off)

	if pfx != "" {
		s += ") "
	} else {
		s += " "
	}

	return s
}

/*
 * Encode non-ASCII chars in URL-encoded format
 * This to make sure control-codes etc do not end up in output
 *
 * We encode in URL-encoded format, but we do not escape HTML chars
 * anything rendering those should handle that part properly.
 *
 * Note: this might not be unicode friendly
 */
func OutEsc(str string) (nstr string) {
	nstr = ""
	for i := 0; i < len(str); i++ {
		c := str[i]

		/* Anything outside of space ' ' to tilde '~' + '%' itself */
		if c < 32 || c > 126 || c == '%' {
			nstr += "%"
			nstr += string("0123456789ABCDEF"[c>>4])
			nstr += string("0123456789ABCDEF"[c&15])
		} else {
			nstr += string(c)
		}
	}
	return
}

/* Silly golang log functions just ignore errors... thus do our own */
func OutA(format string, a ...interface{}) {
	str := fmt.Sprintf(format, a...)

	/* Escape odd chars */
	str = OutEsc(str)

	err := log.Output(2, str)
	if err != nil {
		/* Not really anything else we can do actually */
		fmt.Printf("Logging error '%s' for message: %s", err.Error(), str)
	}
}

/*
 * Logging - centralized and to avoid importing log everywhere
 * Might extend this with extra params to make per-context tracing possible
 */
func ErrA(off int, format string, a ...interface{}) {
	OutA(LogLoc(1+off, "Error")+format, a...)
}

func Err(message string) {
	ErrA(1, message)
}

func Errf(format string, a ...interface{}) {
	ErrA(1, format, a...)
}

func LogA(off int, format string, a ...interface{}) {
	OutA(LogLoc(1+off, "")+format, a...)
}

func Log(message string) {
	LogA(1, message)
}

func Logf(format string, a ...interface{}) {
	LogA(1, format, a...)
}

func DbgA(off int, format string, a ...interface{}) {
	if !Debug {
		return
	}

	where := Where(1 + off)

	pc := make([]uintptr, 10+off)
	runtime.Callers(2+off, pc)
	f := runtime.FuncForPC(pc[0])

	OutA("Debug("+where+") "+f.Name()+" "+format, a...)
}

func Dbg(message string) {
	DbgA(1, message)
}

func Dbgf(format string, a ...interface{}) {
	DbgA(1, format, a...)
}

/* IsTrue() defaults to false if the string is not known */
func IsTrue(val string) (b bool) {
	if val == "yes" || val == "true" || val == "on" {
		b = true
	} else {
		b = false
	}

	return b
}

func YesNo(b bool) (val string) {
	if b == true {
		return "yes"
	}

	return "no"
}

func NormalizeBoolean(val string) string {
	return YesNo(IsTrue(val))
}

/* Parse the string (obeying quoting) */
func SplitArgs(str string) (args []string) {
	r := regexp.MustCompile("'.+'|\".+\"|\\S+")
	return r.FindAllString(str, -1)
}

func Daemon(nochdir int, noclose int) (err error) {
	var ret uintptr
	var ret2 uintptr
	var serr syscall.Errno

	/* Already a daemon? */
	if syscall.Getppid() == 1 {
		return nil
	}

	/* Fork off the parent process */
	ret, ret2, serr = syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)
	if serr != 0 {
		return errors.New("fork() failed")
	}

	/* Fork failure */
	if ret2 < 0 {
		os.Exit(-1)
	}

	/* If we got a good PID, then we call exit the parent process */
	if ret > 0 {
		os.Exit(0)
	}

	/* Change the file mode mask */
	_ = syscall.Umask(0)

	/* Create a new SID for the child process */
	_, err = syscall.Setsid()
	if err != nil {
		return errors.New("Error: syscall.Setsid errno: " + err.Error())
	}

	if nochdir == 0 {
		os.Chdir("/")
	}

	if noclose == 0 {
		f, e := os.OpenFile(os.DevNull, os.O_RDWR, 0)
		if e == nil {
			fd := int(f.Fd())
			syscall.Dup2(int(fd), int(os.Stdin.Fd()))
			syscall.Dup2(int(fd), int(os.Stdout.Fd()))
			syscall.Dup2(int(fd), int(os.Stderr.Fd()))
		}
	}

	return nil
}

func SetUID(username string) (err error) {
	var u *user.User
	var uid int
	var gid int

	u, err = user.Lookup(username)
	if err != nil {
		return err
	}

	uid, err = strconv.Atoi(u.Uid)
	gid, err = strconv.Atoi(u.Gid)

	if gid != 0 {
		if err := syscall.Setgid(gid); err != nil {
			log.Fatalf("failed to Setgid(%d): %v", gid, err)
		}
	}

	if uid != 0 {
		if err := syscall.Setuid(uid); err != nil {
			log.Fatalf("failed to Setuid(%d): %v", uid, err)
		}
	}

	return nil
}

func GetPID() (pid string) {
	return strconv.Itoa(syscall.Getpid())
}

func StorePID(filename string, pid string) {
	err := ioutil.WriteFile(filename, []byte(pid), 0644)
	if err != nil {
		log.Println("Failed to store PID in " + filename + ": " + err.Error())
	}
}

func SortKeys(tbl map[string]string) (keys []string) {
	for k := range tbl {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return
}

func Hex(data []byte) string {
	return fmt.Sprintf("%x", data)
}

func HashIt(input string) (hash string) {
	h := sha256.New()
	h.Write([]byte(input))
	return Hex(h.Sum(nil))
}

func Fullname_to_ident(name string) (out string, err error) {
	/* Force lower case */
	out = strings.ToLower(name)

	/* Only pay attention to the letters in the name */
	validID := regexp.MustCompile(`[^a-z]+`)
	out = validID.ReplaceAllLiteralString(out, "")

	/* Append a random number */
	out += strconv.Itoa(Rand_number(8999) + 1000)

	/* Verify it */
	out, err = Chk_ident("UserName", out)
	return
}

func Chk_ident(name string, in string) (out string, err error) {
	/* Require something at least */
	if in == "" {
		err = errors.New("No " + name + " provided (empty)")
		return
	}

	/* Force lower case */
	out = strings.ToLower(in)

	ok, err := regexp.MatchString(Config.Username_regexp, out)

	if !ok {
		err = errors.New("Invalid characters in " + name + ", only " + Config.Username_regexp + " are allowed")
		return
	}

	/* All okay and filtered */
	return
}

func Image_resize(file io.Reader, maxsize string) (bits []byte, err error) {
	var im image.Image

	s := strings.SplitN(maxsize, "x", 2)
	max_w, _ := strconv.Atoi(s[0])
	max_h, _ := strconv.Atoi(s[1])

	im, _, err = image.Decode(file)
	if err != nil {
		return
	}

	/* Fit it in the box */
	im = imaging.Fit(im, max_w, max_h, imaging.Lanczos)

	/* Re-encode it as a PNG */
	buf := &bytes.Buffer{}
	err = imaging.Encode(buf, im, imaging.PNG)
	if err != nil {
		return
	}

	bits = buf.Bytes()

	return

}

func Rand_number(max int) int {
	s1 := rand.NewSource(time.Now().UnixNano())
	r1 := rand.New(s1)
	return r1.Intn(max)
}

func ToUTF8(iso8859_1_buf []byte) string {
	buf := make([]rune, len(iso8859_1_buf))
	for i, b := range iso8859_1_buf {
		buf[i] = rune(b)
	}
	return string(buf)
}

func CopyFile(ctx PfCtx, verbose bool, source string, dest string) (err error) {
	srcf, err := os.Open(source)
	if err != nil {
		return err
	}

	defer srcf.Close()

	dstf, err := os.Create(dest)

	if err != nil {
		return err
	}

	defer dstf.Close()

	_, err = io.Copy(dstf, srcf)
	if err != nil {
		return
	}

	src, err := os.Stat(source)
	if err != nil {
		err = os.Chmod(dest, src.Mode())

	}

	if verbose {
		ctx.OutLn("Copied File %s -> %s", source, dest)
	}

	return
}

func CopyDir(ctx PfCtx, verbose bool, source string, dest string) (err error) {
	if verbose {
		ctx.OutLn("Copying Directory %s -> %s", source, dest)
	}

	/* Get properties of source directory */
	sourceinfo, err := os.Stat(source)
	if err != nil {
		return err
	}

	/* Create destination directory (may already exist) */
	err = os.MkdirAll(dest, sourceinfo.Mode())
	if err != nil && err != os.ErrExist {
		return err
	}

	dir, err := os.Open(source)
	if err != nil {
		return err
	}

	objs, err := dir.Readdir(-1)

	if err != nil {
		return err
	}

	for _, obj := range objs {
		srcfptr := source + "/" + obj.Name()
		dstfptr := dest + "/" + obj.Name()

		if obj.IsDir() {
			/* Copy sub-directories recursively */
			err = CopyDir(ctx, verbose, srcfptr, dstfptr)
			if err != nil {
				fmt.Println(err)
			}
		} else {
			/* File Copies */
			err = CopyFile(ctx, verbose, srcfptr, dstfptr)
			if err != nil {
				fmt.Println(err)
			}
		}

	}

	return
}

func ThisFunc() string {
	pc := make([]uintptr, 10)
	runtime.Callers(2, pc)
	f := runtime.FuncForPC(pc[0])
	return f.Name()
}

func TrackStart() time.Time {
	return time.Now()
}

func TrackTime(start time.Time, name string) (elapsed time.Duration) {
	elapsed = time.Since(start)
	DbgA(1, "%s took %s", name, elapsed)
	return
}

func Fmt_Time(t time.Time) string {
	if t.IsZero() {
		return "never"
	}

	return t.Format(Config.TimeFormat)
}

func ErrIsDisconnect(err error) bool {
	neterr, ok := err.(net.Error)

	if ok && !neterr.Temporary() || err == io.EOF {
		return true
	}

	return false
}

/* Ensure that a URL ends in a slash */
func URL_EnsureSlash(url string) string {
	if len(url) == 0 || url[len(url)-1] != '/' {
		url += "/"
	}

	return url
}

/* Append two parts of a URL together, adding a '/' in the middle where needed */
func URL_Append(url1 string, url2 string) (url string) {
	url1 = strings.TrimSpace(url1)
	url2 = strings.TrimSpace(url2)

	l1 := len(url1)
	l2 := len(url2)

	if l1 > 0 && url1[l1-1] == '/' {
		if l2 > 0 && url2[0] == '/' {
			/* Both have a '/' */
			url = url1 + url2[1:]
		} else {
			/* 1 has, 2 not */
			url = url1 + url2
		}
	} else {
		if l2 > 0 && url2[0] == '/' {
			/* 1 not, 2 has */
			url = url1 + url2
		} else {
			/* Neither have a '/' */
			url = url1 + "/" + url2
		}
	}

	return
}
